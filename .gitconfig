[user]
	name = <First Last>
	email = <email>
	initials = <fl>
[core]
	editor = code --wait
	safecrlf = warn
	autocrlf = true
[credential]
	helper = manager
[branch "develop"]
	mergeoptions = --no-ff
[branch "master"]
	mergeoptions = --ff-only
[fetch]
	prune = true
[pull]
	rebase = preserve
[push]
	default = simple
	followTags = true
[rerere]
	enabled = true
[workflow]
	featureaffix = feature
	hotfixaffix = hotfix
	releaseaffix = release
	dorebase = false
[alias]
	ec = config --global -e
	amend = commit --amend
	br = branch
	caa = commit -a --amend -C HEAD
	ci = commit -m
	# use without parameters for quick commits with a default message of 'SAVEPOINT" (equivalent to wip or save aliases)
	cm = "!f() { git commit -am \"${1-SAVEPOINT}\"; }; f"
	co = checkout
	cob = checkout -b
	cp = cherry-pick
	cpa = cherry-pick --abort
	cpc = cherry-pick --continue
	# migrate
	# $1 correct / new branch name required
	# $2 target branch name optional defaults to develop
	# $3 commit range optional defaults to the current / wrong branch remote tracking branch
	migrate = "!f() { set -euo pipefail; IFS=$'\\n\\t'; migrate() { local -r correct_br=${1:-}; local -r wrong_br=$(git symbolic-ref --short HEAD); local -r target_br=${2-develop}; [[ -z $correct_br ]] && { git pprint -eo \"'correct_br' is required!$\"; exit 1; }; if [[ -z $(git branch --list \"$correct_br\") ]]; then git checkout -b \"$correct_br\" && git branch -f \"$wrong_br\" \"${3-\"${wrong_br}@{u}\"}\" && git rebase --onto \"$target_br\" \"$wrong_br\" && git pprint -io \"Commits migrated to '$correct_br'\"; else git checkout \"$(git rev-parse HEAD)\" && git branch -f \"$wrong_br\" \"${3-\"${wrong_br}@{u}\"}\" && git rebase --onto \"$correct_br\" \"$wrong_br\" && git checkout -B \"$correct_br\" HEAD && git pprint -io \"Commits migrated to '$correct_br'\"; fi; }; migrate \"$@\"; }; f"
	undo = "!f() { git reset --hard '@{'\"${1-1}\"'}'; }; f"
	unstage = reset HEAD
	rba = rebase --abort
	rbc = rebase --continue
	rbi = "!f() { git rebase -i \"$(git merge-base \"${1-develop}\" \"${2-HEAD}\")\"; }; f"
	rbs = rebase --skip
	wipe = "!f() { git add -A && git commit -qm 'WIPE SAVEPOINT' && git reset --hard HEAD~1; }; f"
	# log
	commit-chain = "!f() { git logbase --graph \"${1-develop}\"..\"${2-HEAD}\"; }; f"
	follow = "!f() { git logbase --graph --follow \"$@\"; }; f"
	last = "!f() { git log --decorate --stat \"${1--1}\" HEAD; }; f"
	logbase = log --pretty='%C(bold blue)%h%C(reset) |%C(auto)%d%C(reset) %C(white)%s%C(reset) %C(bold yellow)(%ar) on (%aD)%C(reset) %C(bold cyan)[%an]%C(reset)'
	lg = "!f() { git logbase --all --graph \"$@\"; }; f"
	rlg = "!f() { git reflog \"$(git rev-parse --abbrev-ref HEAD)\"; }; f"
	st = status
	# oneflow alias b*
	# base command - bnew <-f|h|r[m|u]> branch short name
	# creates and checkout new branch
	# optionally migrates and or updates trunk branch (bpoint)
	bnew = "!f() { set -euo pipefail; IFS=$'\\n\\t'; bnew() { local -r this_br=$(git symbolic-ref --short HEAD); local -r my_intls=$(git config user.initials); local br_afx=''; local br_desc=''; local br_name=''; local br_point=''; local mgt_act=''; local mgt_act_pat=''; local br_flg=''; local mgt_flg=0; local upd_flg=0; cob() { if [[ $this_br != \"$br_point\" ]]; then git checkout \"$br_point\"; fi && { if [[ $upd_flg -eq 1 ]]; then git pprint -io \"Updating branch '$br_point'\"; git pull \"${2-origin}\" \"$br_point\"; fi && git checkout -b \"$br_name\" && git pprint -so \"bnew succeeded!\"; }; return $?; }; migrate() { git bmigrate \"$br_name\" \"$br_point\" && { if [[ $upd_flg -eq 1 ]]; then git bup; fi && git pprint -so \"bnew succeeded!\"; }; return $?; }; while getopts ':fhrum' flg; do case $flg in f) if [[ -z $br_flg ]]; then br_flg=$flg; br_point='develop'; br_afx=$(git config workflow.featureaffix); fi;; h) if [[ -z $br_flg ]]; then br_flg=$flg; br_point='master'; br_afx=$(git config workflow.hotfixaffix); fi;; r) if [[ -z $br_flg ]]; then br_flg=$flg; br_point='develop'; br_afx=$(git config workflow.releaseaffix); fi;; m) mgt_flg=1;; u) upd_flg=1;; *) git pprint -eo \"Invalid option expecting '<-f|h|r[m][u]>'!\"; exit 1;; esac done; shift $((OPTIND - 1)); [[ -z $br_flg ]] && { git pprint -eo \"A flag '<-f|h|r>' indicating the kind of branch to create is required!\"; exit 1; }; br_desc=${1:-}; [[ -z $br_desc ]] && { git pprint -eo \"Option '-$br_flg' requires an argument like my-new-branch!\"; exit 1; }; br_name=${br_afx}\"/${my_intls}/\"$(git check-ref-format --branch \"$(git trimcompactreplacespace -l \"$br_desc\" '-')\"); if [[ -n $(git branch --list \"$br_name\") ]]; then git pprint -eo \"A branch named '$br_name' already exists!\"; elif [[ $mgt_flg -eq 1 || -n $(git status --porcelain) ]]; then if [[ -n $(git status --porcelain) ]]; then if [[ $this_br = 'develop' || $this_br = 'master' ]]; then git pprint -gf \"We noticed your working directory is dirty! - changes must be committed to the new branch '$br_name' (n) or you may abort (a).\\n\" | fold -sw 100; mgt_act_pat=\"^[nN]$|^[aA]$\"; else git pprint -gf \"We noticed your working directory is dirty! Would you like to commit your changes to the new branch $(tput setaf 7)'$br_name'$(tput setaf 5) (n), this_br branch $(tput setaf 7)'$this_br'$(tput setaf 5) (c), or you may abort (a).\\n\" | fold -sw 100; mgt_act_pat=\"^[nN]$|^[cC]$|^[aA]$\"; fi; mgt_act=$(git pprint -pd \"Default is commit to the the new branch '$br_name' (n)?: \") && echo; [[ $mgt_act =~ $mgt_act_pat ]] && mgt_act=$(git trim \"$mgt_act\" | tr '[:upper:]' '[:lower:]') || mgt_act=\"n\"; [[ $mgt_act = \"a\" ]] && exit 0; if [[ $mgt_act = \"c\" ]]; then git bcm && cob \"$@\"; else migrate \"$@\"; fi; else git pprint -gf \"The number of commits you specify will be moved from '$this_br' to the new branch '$br_name'.\" | fold -sw 100; migrate \"$@\"; fi; else cob \"$@\"; fi; }; bnew \"$@\"; }; f"
	# base command - bup <-r> <remote[origin]> <trunk branch[develop]>
	# updates trunk branch
	# updates current branch
	# replay current branch commits onto trunk branch if applicable
	# -r interactive rebase of the current branch if applicable
	bup = "!f() { set -euo pipefail; IFS=$'\\n\\t'; bup() { local -r this_br=$(git symbolic-ref --short HEAD); local br_sync_status=''; local br_remote=''; local did_br_point_upd=0; local did_br_upd=0; local did_br_rply=0; local did_br_rbi=0; local did_proc_push=0; local direct_flg=0; local push_flg=0; local rbi_flg=0; local xpr_flg=0; sync_with_upstream() { local -r br=$1; local -r sync_status=$(git isinsyncwithupstream); if [[ $sync_status = 'out_of_sync' ]]; then git pprint -io \"Updating branch '$br'\"; git pull; elif [[ $sync_status = 'in_sync' ]]; then git pprint -io \"Branch '$br' is up-to-date\"; elif [[ $sync_status = 'upstream_removed' ]]; then git pprint -wo \"Unsetting upstream for '$br'!\"; git branch --unset-upstream; elif [[ $sync_status = 'no_upstream' ]]; then git pprint -io \"No upstream set for branch '$br'\"; fi; return $?; }; push_to_other_remotes() { br_remote=$(git config branch.\"$(git symbolic-ref --short HEAD)\".remote); if [[ -n $br_remote ]]; then for remote in $(git remote show | grep -v \"$br_remote\"); do git pprint -io \"Pushing branch '$this_br' to additional remote '$remote'\"; git push --force-with-lease  \"$remote\" \"$this_br\"; done; fi; return $?; }; while getopts ':dprx' flg; do case $flg in d) direct_flg=1;; p) push_flg=1;; r) rbi_flg=1;; x) xpr_flg=1;; *) git pprint -eo \"Invalid option expecting '[-r|x]'!\"; exit 1;; esac done; shift $((OPTIND - 1)); if ! grep -q \"^${1-origin}$\" <<< \"$(git remote show)\"; then git pprint -eo \"Given remote '${1-origin}' is not valid!\"; exit 1; fi; local -r br_point=${2-develop}; [[ $this_br = 'master' || $br_point = 'master' ]] && git pprint -eo \"Modification of commits on 'master' is not allowed!\" && exit 1; [[ $push_flg -eq 0 && $direct_flg -eq 1 ]] && direct_flg=0; sync_with_upstream \"$this_br\" && did_br_upd=1 && { if [[ $this_br != 'develop' && $xpr_flg -eq 0 ]]; then git checkout \"$br_point\" && sync_with_upstream \"$br_point\" && did_br_point_upd=1 && git checkout \"$this_br\" && { if grep -q \"^feature\" <<< \"$this_br\" && [[ $(git show-ref --heads -s \"$br_point\") != $(git merge-base \"$br_point\" \"$this_br\") ]]; then git pprint -io \"Replaying '$this_br' onto '$br_point'\"; git rebase -p \"$br_point\" && did_br_rply=1; fi; } && git brbi ${rbi_flg} \"$br_point\" \"$this_br\" && did_br_rbi=1; elif [[ $rbi_flg -eq 1 && $this_br = 'develop' ]]; then git pprint -wo \"Rebase is not allowed for 'develop'!\"; elif [[ $rbi_flg -eq 1 && $xpr_flg -eq 1 ]]; then git pprint -wo \"Interactive rebase request will not be honored in eXpress push mode!\"; fi; } && git pprint -so \"bup|fresh succeeded!\" && { [[ $this_br = 'develop' && $push_flg -eq 1 && $direct_flg -eq 0 ]] && git pprint -wo \"Directly pushing to '$this_br' is not allowed!\" && exit 0; br_sync_status=$(git isinsyncwithupstream); [[ $br_sync_status = 'no_upstream' ]] && br_remote='' || br_remote=$(git config --local branch.\"$(git symbolic-ref --short HEAD)\".remote); if [[ $push_flg -eq 1 ]]; then if [[ $br_sync_status = 'no_upstream' ]]; then git pprint -io \"Pushing branch '$this_br' to upstream remote '${1-origin}'\"; git push -u \"${1-origin}\" \"$this_br\"; elif [[ $br_sync_status = 'out_of_sync' ]]; then git pprint -io \"Pushing branch '$this_br' to upstream remote '$br_remote'\"; git push --force-with-lease; elif [[ $br_sync_status = 'in_sync' ]]; then git pprint -wo \"Nothing to push - '$this_br' is in sync with '$br_remote'!\"; fi && push_to_other_remotes && did_proc_push=1; elif [[ $br_sync_status = 'out_of_sync' && ($did_br_rply -eq 1 || $did_br_rbi -eq 1) ]]; then git pprint -wo \"'$this_br' has been previously pushed - syncing with '$br_remote'!\"; git push --force-with-lease && push_to_other_remotes && did_proc_push=1; fi && [[ did_proc_push -eq 1 ]] && git pprint -so \"bpush|saved succeeded!\" || :; }; }; bup \"$@\"; }; f"
	# wrapper command - bfresh -> bup
	bfresh = "!f() { git bup \"$@\"; }; f"
	# base command - bpush <-r> <remote[origin]> <trunk branch[develop]>
	# executes bup
	# pushes current branch to the remote
	bpush = "!f() { set -euo pipefail; IFS=$'\\n\\t'; bpush() { while getopts ':drx' flg; do case $flg in d) ;; r) ;; x) ;; *) git pprint -eo \"Invalid option expecting '[-r|x]'!\"; exit 1;; esac done; git bup -p \"$@\"; }; bpush \"$@\"; }; f"
	# wrapper command - bsaved -> bpush
	bsaved = "!f() { git bpush \"$@\"; }; f"
	# base command - bclean <remote[origin]> <trunk branch[develop]>
	# delete local branches that have been merged or not diverged from trunk branch, develop, or master
	# prunes remote branch references that have been removed from remote
	bclean = "!f() { IFS=$'\\n\\t'; bclean() { local -r merged_br=($(git branch --merged \"${2-develop}\" | grep -Ev \"^${2-develop}|develop|master$\")); set -eo pipefail; [[ ${merged_br[*]} ]] && echo \"${merged_br[*]}\" | xargs git branch -d && git pprint -io \"Merged branches have been pruned\"; git remote prune \"${1-origin}\" && git pprint -io \"Stale tracking branches have been pruned\"; }; bclean \"$@\"; }; f"
    # base command - bdone
	# updates develop branch
	# executes bclean
	bdone = "!f() { set -euo pipefail; IFS=$'\\n\\t'; bdone() { git pprint -io \"Updating branch '${2-develop}'\" && git checkout \"${2-develop}\" && git pull && git bclean \"${1-origin}\" \"${2-develop}\" && git pprint -so \"bdone succeeded!\"; }; bdone \"$@\"; }; f"
	# internal simple gitflow helpers
	bcm = "!f() { set -euo pipefail; IFS=$'\\n\\t'; bcm() { local -r this_br=$(git symbolic-ref --short HEAD); local add_param=''; local commit_msg=''; local did_commit=0; local direct_flg=0; while getopts ':d' flg; do case $flg in d) direct_flg=1;; *) exit 1;; esac done; shift $((OPTIND - 1)); [[ $this_br = 'develop' && $direct_flg -eq 0 ]] && git pprint -eo \"Direct commit to 'develop' is not allowed!\" && exit 1; [[ $this_br = 'master' ]] && git pprint -eo \"Direct commit to 'master' is not allowed!\" && exit 1; if [[ $(git status --porcelain) ]]; then git pprint -gf \"Ok - lets get your working directory committed - here is your status and the last 5 commits.\\n\" | fold -sw 100; git status && echo; git logbase --all --graph -5 && echo; add_param=$(git pprint -pd \"Add tracked and untracked changes (a) or just tracked changes (t)? Default value is just tracked (t): \"); grep -Eiq \"^a$|^t$\" <<< \"$add_param\" && add_param=$(git trim \"$add_param\" | tr '[:upper:]' '[:lower:]') || add_param=\"t\"; commit_msg=$(git pprint -pd \"Enter a commit message. Default value is 'SAVEPOINT': \"); [[ -z $commit_msg ]] && commit_msg='SAVEPOINT' || commit_msg=$(git trim \"$commit_msg\"); if [[ $add_param = \"a\" ]]; then git add -A && git commit -m \"$commit_msg\" && did_commit=1; else git commit -am \"$commit_msg\" && did_commit=1; fi; [[ $did_commit -eq 1 ]] && git pprint -io \"Changes committed\"; else git pprint -wo \"Nothing to commit - working directory is clean!\"; fi; }; bcm \"$@\"; }; f"
	bmigrate = "!f() { set -euo pipefail; IFS=$'\\n\\t'; bmigrate() { local -r correct_br=${1:-}; local -r target_br=${2:-}; local -r wrong_br=${3-$(git symbolic-ref --short HEAD)}; local did_commit=0; local max_commits=0; local num_commits=0; local mv_prompt=''; [[ -z $correct_br ]] && git pprint -eo \"'correct_br' is required!\" && exit 1; [[ -z $target_br ]] && git pprint -eo \"'target_br' is required!\" && exit 1; [[ -z $(git branch --list \"$target_br\") ]] && git pprint -eo \"The branch '$target_br' must exist!\" && exit 1; [[ -z $(git branch --list \"$wrong_br\") ]] && git pprint -eo \"The branch '$wrong_br' must exist!\" && exit 1; [[ $correct_br = \"$wrong_br\" ]] && git pprint -eo \"Check the command parameters - 'correct_br' and 'wrong_br' can not be equal!\" && exit 1; [[ $correct_br = 'master' || $wrong_br = 'master' ]] && git pprint -eo \"Modification of commits on 'master' is not allowed!\" && exit 1; [[ $correct_br = 'develop' ]] && git pprint -wf \"You are attempting to move commits to 'develop' - You may not be able to push 'develop' directly to the remote!\\n\" '\\n' && ABORT=$(git pprint -pd \"Press ENTER to continue or (a) to abort: \") && grep -iq \"^a$\" <<< \"$ABORT\" && exit 1; [[ $wrong_br != $(git symbolic-ref --short HEAD) ]] && git pprint -wf \"Migration requires '$wrong_br' to be the current current branch - attempting to checkout '$wrong_br'!\" '\\n'  && [[ -z $(git checkout \"$wrong_br\" 2>/dev/null) ]] && git pprint -eo \"Checkout of '$wrong_br' failed!\" && exit 1; if [[ -n $(git status --porcelain) ]]; then git bcm -d && did_commit=1; mv_prompt=\"Commit '$(git rev-parse --short HEAD)' will be moved from '$wrong_br' to '$correct_br' - would you like to move additional commits? Max value is max_commits. Default value is 0: \"; else mv_prompt=\"How many commits from '$wrong_br' to '$correct_br' would you like to move? Max value is max_commits. Default value is 0: \"; fi; if [[ -n $(git rev-parse --verify --quiet '@{u}' 2>/dev/null) && $(git rev-list --count @'{u}'..) -gt 0 ]]; then max_commits=$(git rev-list --count @'{u}'..); echo; git logbase @'{u}'..; echo; elif [[ $(git rev-list --count \"$target_br\"..HEAD) -gt 0 ]]; then max_commits=$(git rev-list --count \"$target_br\"..HEAD); echo; git logbase --graph \"$target_br\"..'HEAD'; echo; else git pprint -eo \"No commits on '$wrong_br' can be safely moved!\"; exit 1; fi; [[ $did_commit -eq 1 ]] && max_commits=$((max_commits - 1)); [[ $max_commits -gt 0 ]] && mv_prompt=$(sed 's/max_commits/'\"$max_commits\"'/g' <<< \"$mv_prompt\") && num_commits=$(git pprint -pd \"$mv_prompt\"); [[ ${num_commits} =~ ^[0-9]{1,}$ ]] && { [[ $num_commits -gt $max_commits ]] && num_commits=$max_commits || :; } || num_commits=0; [[ $did_commit -eq 1 ]] && num_commits=$((num_commits + 1)); git migrate \"$correct_br\" \"$target_br\" \"HEAD~$num_commits\"; }; bmigrate \"$@\"; }; f"
	brbi = "!f() { set -euo pipefail; IFS=$'\\n\\t'; brbi() { if [[ $1 -eq 1 ]] || grep -iq \"^true$\" <<< \"$(git config workflow.dorebase)\"; then git pprint -io \"Checking if there are commits for interactive rebase\"; if [[ $(git rev-list --count develop..develop) -gt 0 ]]; then git pprint -io \"Starting interactive rebase for '$3'\"; git rebase -i \"$(git merge-base \"$2\" \"$3\")\"; else git pprint -wo \"No commits between '$2..$3' for interactive rebase!\"; fi; fi; }; brbi \"$@\"; }; f"
	# remote repo
	pushf = push --force-with-lease
	pusht = push --follow-tags
	up = "!f() { git pull \"$@\"; }; f"
	# helpers
	isinsyncwithupstream = "!f() { set -euo pipefail; IFS=$' \\n\\t'; isinsyncwithupstream() { local -r this_br=${1-$(git symbolic-ref --short HEAD)}; local -r remote=$(git config --local branch.\"$this_br\".remote); local -r merge_ref=$(git config --local branch.\"$this_br\".merge); [[ -n $remote &&  -n $merge_ref ]] && local -r upstream_commit=$(git ls-remote \"$remote\" \"$merge_ref\") || local -r upstream_commit=''; if [[ -z $upstream_commit ]]; then if grep -iq \"no upstream\" <<< \"$(git rev-parse --verify \"${this_br}@{u}\" 2>&1)\"; then echo 'no_upstream'; else echo 'upstream_removed'; fi; else [[ $(git rev-parse \"$this_br\") = $(git ls-remote $(git rev-parse --abbrev-ref \"${this_br}@{u}\" | sed 's%/% %g') | cut -f1) ]] && echo 'in_sync' || echo 'out_of_sync'; fi; }; isinsyncwithupstream \"$@\"; }; f"
	pprint = "!f() { set -euo pipefail; IFS=$'\\n\\t'; pprint() { local -r red=$(tput setaf 1); local -r grn=$(tput setaf 2); local -r org=$(tput setaf 3); [[ $(git whichos) != 'WIN' ]] && local -r blu=$(tput setaf 4); [[ $(git whichos) = 'WIN' ]] && local -r blu=$(tput setaf 6); local -r pur=$(tput setaf 5); local -r wht=$(tput setaf 7); local -r rst=$(tput sgr0); local style_flg=''; local cmd_flg=''; while getopts ':egipswdof' flg; do case $flg in e) style_flg='e';; g) style_flg='g';; i) style_flg='i';; p) style_flg='p';; s) style_flg='s';; w) style_flg='w';; d) cmd_flg='d';; f) cmd_flg='f';; o) cmd_flg='o';; *) echo \"$(tput setaf 1)Invalid option expecting '<-e|g|i|p|s[d|o|f]>'!$(tput sgr 0)\"; exit 1;; esac done; shift $((OPTIND - 1)); local string=${1:-}; local -r prefix=${2:-}; local -r postfix=${3:-}; [[ -z $style_flg ]] && { echo \"${red}A flag '<-e|g|i|p|s>' indicating the output style is required!${rst}\"; exit 1; }; [[ -z $cmd_flg ]] && { echo \"${red}A flag '<-d|o|f>' indicating the command to use is required!${rst}\"; exit 1; }; [[ -z $string ]] && { echo \"${red}A string to output is required!${rst}\"; exit 1; }; case $style_flg in e) string=\"${red}==> $string${rst}\";; g) string=\"${pur}==> $string${rst}\";; i) string=\"${blu}==> $string${rst}\";; p) string=\"${wht}==> $string${rst}\";; s) string=\"${grn}==> $string${rst}\";; w) string=\"${org}==> $string${rst}\";; esac; case $cmd_flg in d) read -p \"${prefix}${string}${postfix}\" -r input; echo \"$input\";; o) echo \"${prefix}${string}${postfix}\";; f) printf \"%b\\n\" \"${prefix}${string}${postfix}\";; esac; }; pprint \"$@\"; }; f"
	trim = "!f() { set -euo pipefail; IFS=$'\\n\\t'; trim() { local -r string=${1:-}; [[ -z $string ]] && { git pprint -eo \"A string to operate on is required!\"; exit 1; }; sed 's/^[[:blank:]]*//;s/[[:blank:]]*$//' <<< \"$string\"; }; trim \"$@\"; }; f"
	trimcompactreplacespace = "!f() { set -euo pipefail; IFS=$'\\n\\t'; trimcompactreplacespace() { local lwr_flg=0; local upr_flg=0; while getopts ':lu' flg; do case $flg in l) lwr_flg=1;; u) upr_flg=1;; *) git pprint -eo \"Invalid option expecting '[-l|u]'!\"; exit 1;; esac done; shift $((OPTIND - 1)); local -r string=${1:-}; local pat=${2:-}; [[ -z $string ]] && { git pprint -eo \"A string to operate on is required!\"; exit 1; }; [[ -z $pat ]] && { git pprint -eo \"A relacement string is required!\"; exit 1; }; pat='s/ /'\"$pat\"'/g'; git trim \"$string\" | tr -s ' ' | if [[ lwr_flg -eq 1 ]]; then tr '[:upper:]' '[:lower:]' | sed -e \"$pat\"; elif [[ upr_flg -eq 1 ]]; then tr '[:lower:]' '[:upper:]' | sed -e \"$pat\"; else sed -e \"$pat\"; fi; }; trimcompactreplacespace \"$@\"; }; f"
	whichos = "!f() { set -euo pipefail; IFS=$'\\n\\t'; whichos() { local -r OS=$(uname -s); local os=''; if [[ ${OS:0:6} = 'Darwin' ]]; then os='OSX'; elif [[ ${OS:0:5} = 'Linux' ]]; then os='LINUX'; elif [[ ${OS:0:10} = 'MINGW32_NT' ]]; then os='WIN'; elif [[ ${OS:0:10} = 'MINGW64_NT' ]]; then os='WIN'; fi; echo \"$os\"; }; whichos; }; f"
	# experimental / testing
	colors = "!f() { set -euo pipefail; IFS=$'\\n\\t'; for i in {0..7}; do echo \"$(tput setaf \"$i\")Color $i$(tput sgr 0)\"; done; }; f"
	commandwithparams = "!f() { set -euo pipefail; IFS=$'\\n\\t'; echo \"${1-1}\" \"${2-2}\"; }; f"
	parampass = "!f() { set -euo pipefail; IFS=$'\\n\\t'; git commandwithparams \"$@\"; }; f"
	temptyparam = "!f() { set -euo pipefail; IFS=$'\\n\\t'; if [[ ! -z ${1:-} ]]; then echo \"$1\"; echo \"${1// }\"; else echo 'Empty param'; fi; }; f"
	tgetopts = "!f() { set -euo pipefail; IFS=$'\\n\\t'; while getopts ':abc' flg; do case $flg in *) echo \"$flg\" $OPTIND \"${OPTARG:-}\";; esac done; }; f"
[diff]
	tool = semanticmerge
	#tool = vscode
[difftool]
	prompt = false
[difftool "semanticmerge"]
	cmd = \"C:\\Users\\<UserName>\\AppData\\Local\\semanticmerge\\semanticmergetool.exe\" -s \"$LOCAL\" -d \"$REMOTE\"
[difftool "vscode"]
	cmd = code --wait --diff $LOCAL $REMOTE
[merge]
	tool = semanticmerge
[mergetool]
  	prompt = false
  	keepBackup = false
[mergetool "semanticmerge"]
	cmd = \"C:\\Users\\<UserName>\\AppData\\Local\\semanticmerge\\semanticmergetool.exe\" -s \"$LOCAL\" -d \"$REMOTE\" -b \"$BASE\" -r \"$MERGED\"
	trustExitCode = true
